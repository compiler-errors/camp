use camino::Utf8Path;

use crate::files::{Files, FileId};
use crate::result::Error;
use crate::parser::*;

grammar(files: &mut Files, file_id: FileId, file_name: &str, file_name_span: Span);

extern {
    type Error = Error;
    type Location = usize;
}

CommaSep<T>: Vec<T> = {
    <T> => vec![<>],
    <mut v:(<T> ",")+> <e:T?> => { v.extend(e); v },
};

CommaSepZero<T>: Vec<T> =
    <mut v:(<T> ",")*> <e:T?> => { v.extend(e); v };

PlusSep<T>: Vec<T> = 
    <mut v:(<T> "+")*> <e:T> => { v.push(e); v };

Tok<T>: Span =
    <l:@L> T <r:@R> => Span(file_id, l, r);

//

Identifier: Identifier = <l:@L> r"_?[a-z][a-z0-9_]*" <r:@R> => Identifier { name: <>.to_string(), span: Span(file_id, l, r) };

Typename: Typename = <l:@L> r"_?[A-Z][a-z0-9_]*" <r:@R> => Typename { name: <>.to_string(), span: Span(file_id, l, r) };

Number: String = r"[0-9][0-9_]*" => <>.to_string();

//

pub FileModule: Module = 
    <l:@L> <items:ModuleItem*> => 
        Module { 
            mod_name: Identifier { name: file_name.to_string(), span: file_name_span },
            items,
        };

ModuleItem: ModuleItem = {
    /// A submodule declaration in a separate file
    "mod" <Identifier> ";" =>
        ModuleItem::ModuleDeclaration(<>),

    /// A submodule with definition located in the same file
    "mod" <mod_name:Identifier> "{" <items:ModuleItem*> "}" => 
        ModuleItem::Module(Module { mod_name, items }),

    "use" <Path> ";" => 
        ModuleItem::Use(<>),

    Struct => 
        ModuleItem::Struct(<>),

    Function => 
        ModuleItem::Function(<>),

    //Trait => 
    //    ModuleItem::Trait(<>),

    //Impl => 
    //    ModuleItem::Impl(<>),
};

Function: Function =
    <sig:Signature> "=" <body:Expr> ";" =>
        Function { sig, body };

Signature: Signature =
    "fn" <name:Identifier> <generics:GenericsDecl> <params:Params> <restrictions:Restrictions> =>
        Signature { name, generics, params: params.0, has_self: params.1, restrictions };

Params: (Vec<Param>, Option<Span>) = {
    <self_param:SelfParam> "," <params:CommaSepZero<Param>> => {
        let span = self_param.name.span;
        params.insert(0, self_param);
        Ok(params, Some(span))
    },
    <params:CommaSepZero<Param>> => (params, None),
}

Param: Param =
    <name:Identifier> ":" <ty:Ty> =>
        Param { name, ty };

SelfParam: Param = {
    <span:Tok<"self">> => Param {
        name: Identifier::self_id(span),
        ty: Ty { kind: TyKind::Self, span },
    },
    <l:LifetimeStart> <span:Tok<"self">> => {
        let ty = 

        Param {
            name: Identifier::self_id(s),
            ty,
        },
    }
}

LifetimeStart = <amp:Tok<"&">> <lifetime:Lifetime?> <mutability:Tok<"mut">?>;

Struct: Struct =
    "struct" <name:Typename> <generics:GenericsDecl> <restrictions:Restrictions> "{" <members:CommaSepZero<Member>> "}" => 
        Struct { name, generics, restrictions, members };

Member: Member =
    <name:Identifier> ":" <ty:Ty> =>
        Param { name, ty };

GenericsDecl = {
    "<" <CommaSep<Typename>> ">",
    () => vec![],
};

Restrictions = {
    "where" <CommaSep<Restriction>>,
    () => vec![],
};

Restriction =
    <Ty> ":" <PlusSep<TraitTypeWithBindings>>;

Type: Type = {
    "Int" => Type::Int,
};

/////// TODO:

Expr: String = {
    "Sized" => <>.to_string(),
};

Path: String = {
    "Sized" => <>.to_string(),
};

TraitType: String = {
    "Sized" => <>.to_string(),
};

TraitTypeWithBindings: String = {
    "Sized" => <>.to_string(),
};
