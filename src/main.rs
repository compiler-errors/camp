#![feature(never_type)]
#![feature(extended_key_value_attributes)]
#![feature(or_patterns)]
#![feature(unwrap_infallible)]

pub mod files;
pub mod lexer;
pub mod parser;
pub mod result;
#[cfg(test)]
mod ui_test;
pub mod util;

#[macro_use]
extern crate log;

use camino::Utf8PathBuf;
use codespan_derive::IntoDiagnostic;
use log::LevelFilter;
use simple_logger::SimpleLogger;
use structopt::StructOpt;

use files::{calculate_root_path, Files};
use lexer::lex_file;
use parser::item::Mod;
use result::{Error, Result};
use termcolor::{ColorChoice, StandardStream};

#[derive(StructOpt, Debug)]
struct Args {
    /// Verbosity level. 0 = Errors, 1 = Info, 2 = Debug, 3+ = Trace
    #[structopt(short, parse(from_occurrences = log_level))]
    verbose: LevelFilter,
    /// Exclude color from terminal output
    #[structopt(long)]
    no_color: bool,
    /// Compile mode
    #[structopt(subcommand)]
    mode: Mode,
}

fn log_level(verbose: u64) -> LevelFilter {
    match verbose {
        0 => LevelFilter::Error,
        1 => LevelFilter::Info,
        2 => LevelFilter::Debug,
        _ => LevelFilter::Trace,
    }
}

#[derive(StructOpt, Debug)]
enum Mode {
    Lex {
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        file: Utf8PathBuf,
    },
    /// Parse the root module and declared submodules
    Parse {
        /// The root module of the program
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        root: Utf8PathBuf,
        /// The file
        #[structopt(long)]
        root_file: Option<String>,
    },
    /// Lower and typecheck the root module, any additional libraries, and
    /// stdlib
    Verify {
        /// The root module of the program
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        root: Utf8PathBuf,
        /// Root file for stdlib, defaults to `PARSER_ROOT/std/lib.ox`
        #[structopt(long, parse(from_str = Utf8PathBuf::from))]
        stdlib: Option<Utf8PathBuf>,
    },
    /// Compile the root module, any additional libraries, and stdlib into a
    /// binary
    Compile {
        /// The root module of the program
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        root: Utf8PathBuf,
        /// Root file for stdlib, defaults to `PARSER_ROOT/std/lib.ox`
        #[structopt(long, parse(from_str = Utf8PathBuf::from))]
        stdlib: Option<Utf8PathBuf>,
        /// Output path of the executable generated by successful compilation
        #[structopt(parse(from_str = Utf8PathBuf::from), default_value = "camp.out")]
        output: Utf8PathBuf,
    },
}

impl Mode {
    /// Turn a compiler mode args enum into a displayable string
    fn name(&self) -> &'static str {
        match self {
            Mode::Lex { .. } => "lex",
            Mode::Parse { .. } => "parse",
            Mode::Verify { .. } => "verify",
            Mode::Compile { .. } => "compile",
        }
    }
}

fn main() -> ! {
    // Parse arguments, bailing if we have mistyped
    let args = Args::from_args();

    // Set up logging with the declared verbosity (see `crate::log_level`)
    SimpleLogger::new().with_level(args.verbose).init().unwrap();

    let mut files = Files::new();

    let output = match args.mode {
        Mode::Lex { file } => lex_stage(&mut files, file),
        Mode::Parse { root, root_file } => parse_stage(&mut files, root, root_file),
        mode => Err(Error::UnsupportedMode(mode.name())),
    };

    std::process::exit(match output {
        Ok(()) => 0,
        Err(e) => {
            let color = if args.no_color {
                ColorChoice::Never
            } else {
                ColorChoice::Auto
            };
            let mut writer = StandardStream::stderr(color);
            let config = codespan_reporting::term::Config::default();
            codespan_reporting::term::emit(&mut writer, &config, &files, &e.into_diagnostic())
                .unwrap();
            // Exit with code 1
            1
        },
    })
}

fn lex_stage(files: &mut Files, file_path: Utf8PathBuf) -> Result<()> {
    let buf = lex_file(files, &file_path)?;

    for t in &buf.tokens {
        println!("{:?}", t);
    }

    Ok(())
}

fn parse_stage(files: &mut Files, root_path: Utf8PathBuf, root_file: Option<String>) -> Result<()> {
    let (submod_path, file_path) = calculate_root_path(&root_path, root_file.as_deref())?;
    let root_mod = Mod::parse_file(None, files, &file_path, &submod_path)?;

    println!("{:#?}", root_mod);

    Ok(())
}
