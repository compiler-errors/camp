pub mod files;
pub mod parser;
pub mod result;
pub mod util;

#[macro_use]
extern crate log;

use camino::Utf8PathBuf;
use codespan_derive::IntoDiagnostic;
use codespan_reporting::term::termcolor::{ColorChoice, StandardStream};
use files::Files;
use log::LevelFilter;
use simple_logger::SimpleLogger;
use structopt::StructOpt;

use parser::parse_root_module;
use result::{Result, Error};

#[derive(StructOpt, Debug)]
struct Args {
    /// Verbosity level. 0 = Errors, 1 = Info, 2 = Debug, 3+ = Trace
    #[structopt(short, parse(from_occurrences = log_level))]
    verbose: LevelFilter,
    /// Compile mode
    #[structopt(subcommand)]
    mode: Mode,
}

fn log_level(verbose: u64) -> LevelFilter {
    match verbose {
        0 => LevelFilter::Error,
        1 => LevelFilter::Info,
        2 => LevelFilter::Debug,
        _ => LevelFilter::Trace,
    }
}

#[derive(StructOpt, Debug)]
enum Mode {
    /// Parse the root module and declared submodules
    Parse {
        /// The root module of the program
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        root: Utf8PathBuf,
    },
    /// Lower and typecheck the root module, any additional libraries, and
    /// stdlib
    Verify {
        /// The root module of the program
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        root: Utf8PathBuf,
        /// Additional library modules that will parsed alongside the root
        /// module
        #[structopt(short, long = "lib", parse(from_str = Utf8PathBuf::from))]
        libraries: Option<Vec<Utf8PathBuf>>,
        /// Root file for stdlib, defaults to `PARSER_ROOT/std/lib.ox`
        #[structopt(long, parse(from_str = Utf8PathBuf::from))]
        stdlib: Option<Utf8PathBuf>,
    },
    /// Compile the root module, any additional libraries, and stdlib into a
    /// binary
    Compile {
        /// The root module of the program
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        root: Utf8PathBuf,
        /// Additional library modules that will parsed alongside the root
        /// module
        #[structopt(short, long = "lib", parse(from_str = Utf8PathBuf::from))]
        libraries: Option<Vec<Utf8PathBuf>>,
        /// Root file for stdlib, defaults to `PARSER_ROOT/std/lib.ox`
        #[structopt(long, parse(from_str = Utf8PathBuf::from))]
        stdlib: Option<Utf8PathBuf>,
        /// Output path of the executable generated by successful compilation
        #[structopt(parse(from_str = Utf8PathBuf::from), default_value = "oxia.out")]
        output: Utf8PathBuf,
    },
}

impl Mode {
    /// Turn a compiler mode args enum into a displayable string
    fn name(&self) -> &'static str {
        match self {
            Mode::Parse { .. } => "parse",
            Mode::Verify { .. } => "verify",
            Mode::Compile { .. } => "compile",
        }
    }
}

fn main() {
    // Parse arguments, bailing if we have mistyped
    let args = Args::from_args();

    // Set up logging with the declared verbosity (see `crate::log_level`)
    SimpleLogger::new().with_level(args.verbose).init().unwrap();

    let mut files = Files::new();

    let output = match args.mode {
        Mode::Parse { root } => parse_stage(&mut files, root),
        mode => Err(Error::UnsupportedMode(mode.name())),
    };

    match output {
        Ok(()) => {},
        Err(e) => {
            let writer = StandardStream::stderr(ColorChoice::Always);
            let config = codespan_reporting::term::Config::default();
            codespan_reporting::term::emit(
                &mut writer.lock(),
                &config,
                &files,
                &e.into_diagnostic(),
            )
            .unwrap();
        },
    }
}

fn parse_stage(files: &mut Files, root: Utf8PathBuf) -> Result<()> {
    let root = parse_root_module(files, &root)?;

    info!("Parsed: {:#?}", root);

    Ok(())
}
