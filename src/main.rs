use camino::Utf8PathBuf;
use camp_driver::{lex_stage, parse_stage, verify_stage, CampDb, CampsiteArg, DriverError};
use codespan_derive::IntoDiagnostic;
use structopt::StructOpt;
use termcolor::{ColorChoice, StandardStream};

#[derive(StructOpt, Debug)]
struct Args {
    /// Exclude color from terminal output
    #[structopt(long)]
    no_color: bool,
    /// Compile mode
    #[structopt(subcommand)]
    mode: Mode,
}

#[derive(StructOpt, Debug)]
enum Mode {
    Lex {
        #[structopt(parse(from_str = Utf8PathBuf::from))]
        file: Utf8PathBuf,
    },
    /// Parse the site module and declared submodules
    Parse {
        /// The site module of the program
        #[structopt()]
        campsite_file: CampsiteArg,
    },
    /// Lower and typecheck the site module, any additional libraries, and
    /// stdlib
    Verify {
        /// The main site of the program, formatted like
        /// name=path/to/project/site/main.camp
        #[structopt()]
        site: CampsiteArg,
        #[structopt(long, short = "L")]
        libs: Vec<CampsiteArg>,
    },
    /// Compile the site module, any additional libraries, and stdlib into a
    /// binary
    Compile {
        /// The main site of the program, formatted like
        /// name=path/to/project/site/main.camp
        #[structopt()]
        site: CampsiteArg,
        #[structopt(long, short = "L")]
        libs: Vec<CampsiteArg>,
        /// Output path of the executable generated by successful compilation
        #[structopt(parse(from_str = Utf8PathBuf::from), default_value = "camp.out")]
        output: Utf8PathBuf,
    },
}

impl Mode {
    /// Turn a compiler mode args enum into a displayable string
    fn name(&self) -> &'static str {
        match self {
            Mode::Lex { .. } => "lex",
            Mode::Parse { .. } => "parse",
            Mode::Verify { .. } => "verify",
            Mode::Compile { .. } => "compile",
        }
    }
}

fn main() {
    env_logger::init();

    // Parse arguments, bailing if we have mistyped
    let args = Args::from_args();

    let mut db = CampDb::default();

    let output = match args.mode {
        Mode::Lex { file } => lex_stage(&mut db, file),
        Mode::Parse { campsite_file } => parse_stage(&mut db, campsite_file),
        Mode::Verify { site, libs } => verify_stage(&mut db, site, libs),
        mode => Err(DriverError::UnsupportedMode(mode.name()).into()),
    };

    if let Err(err) = output {
        let color = if args.no_color {
            ColorChoice::Never
        } else {
            ColorChoice::Auto
        };
        let mut writer = StandardStream::stderr(color);
        let config = codespan_reporting::term::Config::default();

        codespan_reporting::term::emit(&mut writer, &config, &db, &err.into_diagnostic()).unwrap();

        // Exit with code 1
        std::process::exit(1);
    }
}
